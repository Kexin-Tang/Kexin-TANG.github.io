[{"title":"How to write 'hello world' in HEXO (I)","url":"/2021/04/18/How-to-write-hello-world-in-HEXO-I/","content":"What is HEXO?HEXO is a very famous and useful web framework. People always combine HEXO with GitHub to bulid their own blogs or webpages.\nInstallFirst of all, you need to install node.js, you can refer to its website here, and git, you can refer here.\nAfter configuration, you are supposed to install HEXO via node.js command called npm.\nnpm install -g hexo-cli\n\nInitializeOnce HEXO is installed, run the following commands to initialize HEXO in the target &lt;folder&gt;.\nhexo init &lt;folder&gt;  # initcd &lt;folder&gt;npm install         # install other dependency\n\nOnce initialized, here’s what your project folder will look like:\n.├── _config.yml         # user can config settings here├── package.json        # record dependency etc.├── scaffolds           # define three post methods -- post, draft and page├── source              # store your posts and other resources|   ├── _drafts|   └── _posts└── themes              # user&#39;s custom themes\n\nConfigurationIn _config.yml file, you can stylize your own settings. For example:\n\ntitle – your website’s name\nurl – the URL of your website\n\nyou can find more details here.\nCommandnewhexo new [layout] [-p/--path filePath] &lt;title&gt;\n\nCreates a new article. If no [layout] is provided, Hexo will use the default_layout from _config.yml. \nBy default, Hexo will use the title to define the path of the file. For page, it will create a directory of that name and an index.md file in it. Use the –path option to override that behaviour and define the file path:\nhexo new page --path about/me &quot;About&quot;\nwill create source/about/me.md file with the title “About” set in the front matter.\nFor post, it will automatically generate a new file in source/_posts/&lt;title&gt;.md\nserverhexo serverhexo s\nRun a local server.\ngeneratehexo g\nGenerate static files, which means it will convert/render .md or .ejs files to html files.\ncleanhexo clean\n\nCleans the cache file (db.json) and generated files (public).\ndeployhexo d\n\nDeploy your files to remote server. You can set your deploy destination:\n\nopen _config.yml\nconfigure depoly area, for example, if you want to deploy your website in GitHubdeploy:    type: git    repository: https://github.com/xxx/xxx.github.io.git    branch: master\n\n","categories":["Web","HEXO","Framework","HEXO"],"tags":["hexo","web","framework"]},{"title":"How-to-write-hello-world-in-HEXO-II","url":"/2021/04/19/How-to-write-hello-world-in-HEXO-II/","content":"Post your fileNow, you can begin to write your markdown or ejs files. When you want to post a file, you can just run codes in orders.\n\nhexo new post &lt;fileName&gt;\nwrite something\nhexo clean\nhexo g\nhexo d\n\nFront-matterWhen you new a file, HEXO will automatically generate a file in certain format, it depends on your METHOD (like post, draft and page) in scaffolds.\nFor POST METHOD, it will generate a file with beginning below:\n---title: &lt;fileName&gt;date: &lt;createTime&gt;---\n\nIn HEXO, the beginning area which surrounded by --- is HEXO’s syntax. title represents the file’s title, and data represents the create time. \nFor instance, when we use below Front-matter, we can get corresponding webpage.\n---title: HELLOdate: 2021-04-19---&lt;main&gt;\n\n&lt;h1&gt;HELLO&lt;&#x2F;h1&gt;[Username] &lt;span&gt;2021-04-19&lt;&#x2F;span&gt; &lt;main&gt;\n\n\ncategories &amp; tagsExcept title and date, there are many other key words:\n\ncategories – indicates the categories it belongs to\ntags – indicates the tags it has\n\nNotice: categories is different with tags. tags is unordered, while categories is ordered.\n---title: date:categories:- Web- HEXOtags:- web- hexo---\n\nThis file will be attached tags with “web” and “hexo”, these tags are parallel. However, it also will be archived to Web and HEXO, and Web is father category, HEXO is child category.\n\n\nIf you want to assign many father-child categories, you can use []\ncategories:- [Web, HEXO]- [Web, Framework]\n","categories":["Web","HEXO","Framework","HEXO"],"tags":["hexo","web","framework"]},{"title":"hexo-pdf","url":"/2021/04/18/hexo-pdf/","content":"If you want to insert .pdf files in your HEXO pages, there are two methods.\n\nMETHOD 0\n\nYou can install HEXO package hexo-pdf.\nnpm install --save hexo-pdf\n\nThen, you can use .ejs syntax &#123;% pdf path %&#125; to achieve function.\n&#123;% pdf https:&#x2F;&#x2F;drive.google.com&#x2F;xxx %&#125;  # external url&#123;% pdf .&#x2F;xxx.pdf %&#125;                     # file path\n\n\nMETHOD 1\n\nIn your index.md, you can use html syntax to achieve this function.\n&lt;object data=&quot;https://drive.google.com/xxx&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;object data=&quot;./xxx.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;\n\n\nYou can adjust the width and height even other properties.\n\n","categories":["Web","HEXO","Framework","HEXO"],"tags":["hexo","web","package"]},{"title":"编译型语言和解释型语言","url":"/2021/04/19/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80/","content":"编译型语言和解释型语言计算机是不能理解高级语言的，更不能直接执行高级语言，它只能直接理解机器语言，所以使用任何高级语言编写的程序若想被计算机运行，都必须将其转换成计算机语言，也就是机器码。而转换主要有两种方法\n\n编译 – 先进行转换，然后再运行\n\n解释 – 运行的过程中进行转换\n\n\n编译型语言使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式(如.exe)。由于已经生成了可执行格式，以后运行时不需要编译，所以编译型语言执行效率高(编译一次，多次使用)。\n一般而言，编译型语言有以下特点：\n\n编译后无需再次编译，性能好\n针对特定平台，跨平台性能差\n\n由于有以上的特点，所以编译型语言常用于OS，嵌入式等对性能要求极高的特定平台，所以衍生出的经典语言类型有 – C/C++\n解释型语言使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。\n一般而言，解释型语言有以下特点：\n\n由于在执行时再翻译，每次执行都要翻译，效率低\n只要对应平台有相应的解释器即可运行，跨平台性能好，便于移植\n\n由于有以上的特点，所以解释型语言常用于Web，脚本等跨平台使用的场景，所以衍生出的经典语言类型有 – Python, Javascript\n关于JavaJava是一种很特殊的语言，其需要将.java文件通过编译生成.class文件，但是该.class文件却可以在各种平台上使用，因为java针对不同的平台有不同的JVM，实现了跨平台。\n\n\n你可以说它是编译型的：因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。 \n你可以说它是解释型的：因为java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的，那也就算是解释的了。 \n但是，现在的JVM为了效率，都有一些JIT优化。它又会把.class的二进制代码编译为本地的代码直接运行，所以，又是编译的。\n\n\n\n为什么需要编译编译有两个主要的好处：\n\n可以提前排除错误;\n对于Java而言，编译并不会直接像C++一样产生基于特定系统的机器码，而是会产生一个二进制比特文件(又称为class文件)，这个文件可以在多种平台被识别(通过JVM)，然后再基于特定的系统进一步进行翻译，实现跨平台与高效率的trade-off\n\n","categories":["Program Language","Java"],"tags":["Java","Concept"]}]