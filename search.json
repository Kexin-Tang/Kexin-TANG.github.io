[{"title":"Celery和AJAX配合实现异步刷新","url":"/2021/04/23/Celery%E5%92%8CAJAX%E9%85%8D%E5%90%88%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0/","content":"需求介绍由于 Celery 是异步队列，有时候用户的页面已经显示出来，但是后台仍在执行任务，我们想实现这样一个功能：当后台执行任务完成后，前端页面相应进行改变。\n这样的场景和需求非常常见，比如上传视频这个过程非常耗时，我们希望用户点击上传视频后，页面马上显示一个区域，表示某视频正在上传（比如视频的图片、标题、简介等马上显示出来），但是此时还不能点击观看（disable链接），只有当后台上传完毕后，才能在前端开放（enable链接）。\n在之前的Celery消息队列中已经介绍过 Celery，此处先简介 Ajax。\nAJAXAsynchronous JavaScript and XML。可以实现每次只使用HTTP请求一小部分资源并加载页面的某一些部分，而不用请求整个页面的所有资源并刷新整个页面所有内容。比较常见的 AJAX 使用场景就是在网页中“下拉显示更多”这样的操作。\n一般而言使用 AJAX 都需要搭配使用 jQuery，其常见的语法如下：\n$(document).ready(function()&#123;            $(&quot;.btn&quot;).click(function() &#123;        // 点击btn时会调用下面的函数                let id = $(&#x27;#id&#x27;).val();        // 获取id的值                $.ajax(&#123;                    url: &quot;&quot;,                    // 要发送请求的url，可以使用mako等模板                    type: &quot;GET&quot;,                // 请求的方式                    data: &#123;&#x27;id&#x27;: id&#125;,           // 一并发送的数据                        success: function(results)&#123; // 如果成功请求                        ...                    &#125;,                    error: function(error) &#123;    // 如果发生错误                        ...                    &#125;                &#125;);            &#125;);        &#125;);\n\n代码\n首先将操作放入 celery 异步队列中，得到一个 &lt;celery.result.AsyncResult&gt; 返回，最重要的是访问其中 id 属性，可以通过 id 访问最终队列的执行结果；\n&#x27;&#x27;&#x27;    function.py&#x27;&#x27;&#x27;class Func(View):    def get(req):        ...        task = celeryFunction.delay() # 得到一个&lt;celery.result.AsyncResult&gt;        ...        return render_to_redirect(req, self.TEMPLATE, data = &#123;&#x27;task_id&#x27;: task_id&#125;)  # 一定要将 task_id 保存住\n然后编写HTML页面用于直接显示内容，可以包含已处理的和待处理的，里面加上 ajax，而 ajax 中的 url 指向某个路由，用于访问执行结果并进行返回；\n$(document).ready(function()&#123;            $(&quot;.refresh&quot;).click(function() &#123;                let task_id = $(&#x27;#task_id&#x27;).val();                $.ajax(&#123;                    url: &quot;$&#123;reverse(&#x27;check&#x27;)&#125;&quot;,                    type: &quot;GET&quot;,                    data: &#123;&#x27;task_id&#x27;: task_id&#125;,                    success: function(results)&#123;                        // 根据最终返回的JSON内容改变本页面的内容                    &#125;,                &#125;);            &#125;);        &#125;);\n在 urls.py 中将上面 ajax 需要跳转的页面进行注册\nurlpatterns &#x3D; [    ...    path(&#39;check&#39;, views.check, name&#x3D;&quot;check&quot;),    ...]\n编写上述新加入的页面函数逻辑，并返回 JsonResponse 进入 ajax 的处理函数中（如 success 中，从而可以改变原有页面内容）\n&#x27;&#x27;&#x27;    views.py&#x27;&#x27;&#x27;from django.http import JsonResponsefrom celery.result import AsyncResultdef check(request):    task_id = request.GET.get(&#x27;task_id&#x27;)    if task_id:        task_res = AsyncResult(task_id)        return JsonResponse(&#123;&#x27;finish&#x27;: task_res.ready()&#125;)    return JsonResponse(&#123;&#x27;finish&#x27;: False&#125;)\n\n坑\n在返回给 ajax 信息时，一定要使用类似于 JSON 的格式，所以推荐使用 JsonResponse。\n\n如果你的 Celery 不幸给你返回了 HTTP 500，那么恭喜你，你应该是没有在 Celery 里设置 backend，也就是说你的服务器只负责帮你执行任务，但是不会把结果及相关信息存储到数据库。（别问我怎么知道的，现在正在东九五楼吹风呢）\n\n\n","categories":["Python","Web","Django","Python"],"tags":["python","django","redis","消息队列"]},{"title":"Celery消息队列","url":"/2021/04/22/Celery%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","content":"什么是任务队列？任务队列就是一种类似“队列”(Queue)的数据结构，是一种用于线程或计算机之间分配工作的一种机制。可以理解为把多个任务按次序放入队列中，然后当有任务完成后就会被取出。\n什么是 Celery ？Celery是一种使用Python编写的任务队列，主要概念有：\n\n中间人（Broker）\n\n中间人（Broker）是一个消息传输的中间件。Celery通过消息机制进行通信，通常使用中间人（Broker）作为客户端和职程（Worker）调节。启动一个任务，客户端向消息队列发送一条消息，然后中间人（Broker）将消息传递给一个职程（Worker），最后由职程（Worker）进行执行中间人（Broker）分配的任务。\nCelery是没有Broker的，需要使用第三方方案。常用的有： RabbitMQ, Redis 和数据库。\n\nbackend\n\n通常程序发送的消息，发完就完了，可能都不知道对方时候接受了。为此，celery实现了一个backend，用于存储这些消息以及celery执行的一些消息和结果。一般而言，同样可以使用 Redis 或者 Django ORM 对这些结果进行存储和操作。\n\n\n\n安装 Celery本文不赘述，可以参考网上各种帖子，一般而言只需要执行以下的指令即可\npip install celery[&#x27;redis&#x27;]\n\n在 Django 中使用 Celery\n注意，在使用 Celery 前一定要启动 Redis 等服务器。\n\n配置非配置文件法app | |- tasks |    | |    |- task.py            &lt;- 用户创建，存放功能函数 |- config |    | |    |- settings.py        &lt;- Django 自带的 settings.py |    |- celeryConfig.py    &lt;- 用户创建，初始化 Celery\n\n&#x27;&#x27;&#x27;    celeryConfig.py&#x27;&#x27;&#x27;import celeryimport os# 参数0为固定设置，参数1为settings的路径os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;config.settings&quot;)import djangodjango.setup()# main为当前模块的名称，broker设置中间人URL，backend设置存储URLapp = celery.Celery(main=&quot;videoweb&quot;, broker=&#x27;redis://localhost:6379/2&#x27;, backend=&#x27;redis://localhost:6379/3&#x27;)# 定义会使用 &#x27;app&#x27; 这个消息队列的文件的位置app.autodiscover_tasks([&#x27;app.tasks&#x27;])\n\n&#x27;&#x27;&#x27;    task.py&#x27;&#x27;&#x27;from app.config.celeryConfig import appimport time@app.taskdef func():    # 一些需要放在异步队列中运行的，比较耗时/会造成阻塞的任务代码\n\n配置文件法app | |- tasks |    | |    |- task.py            &lt;- 用户创建，存放功能函数 |- config |    | |    |- settings.py        &lt;- Django 自带的 settings.py |- celery |    | |    |- celeryConfig.py    &lt;- 用户创建，设置信息 |    |- celeryApp.py       &lt;- 用户创建，初始化 celery\n\n\n注意， celery 相关的设置和初始化需要放在同一个文件夹下\n\n&#x27;&#x27;&#x27;    celeryConfig.py&#x27;&#x27;&#x27;BROKER_URL = &#x27;redis://127.0.0.1:6379&#x27;               # 指定 BrokerCELERY_RESULT_BACKEND = &#x27;redis://127.0.0.1:6379/0&#x27;  # 指定 Backend                        CELERY_IMPORTS = (                                  # 指定导入的任务模块    &#x27;app.tasks.task&#x27;)\n\n&#x27;&#x27;&#x27;    celeryApp.py&#x27;&#x27;&#x27;from celery import Celeryapp = Celery(&#x27;videoweb&#x27;)app.config_from_object(&#x27;celeryConfig&#x27;)   # 加载配置\n\n&#x27;&#x27;&#x27;    task.py&#x27;&#x27;&#x27;from app.celery.celeryApp import app@app.taskdef func():    # 一些需要放在异步队列中运行的，比较耗时/会造成阻塞的任务代码\n\n使用在配置完成后，需要手动启动 celery 服务\n# 代表将使用videoweb注册的app放入异步队列，使用4个workercelery -A videoweb worker -c 4 -l info  \n\n在其他文件中需要调用func()时，可以使用func.delay()的格式，即可将func()函数放到异步队列中运行。\n\n注意，在使用.delay(params)的时候，params只能是可解析格式，如list, str, int, json等，不能是类似于Queryset之类的内容。\n\n查看执行的结果由于是异步进程，执行的结果可能不会在编写的代码中体现，所以需要在后续重新读取执行的结果并对页面等进行相应的改动。\n实现该过程的方法就是使用 AJAX。这并不在本文的讨论范围内，本文主要告知如何访问消息队列中的程序。\n在使用func.delay()时，会返回一个 AsyncResult 实例，其有一些属性和方法，如 id, successful() 和 *failed()*。一般而言，我们会将 id 一并传入 Django 的 Template 视图中，然后编写 AJAX，读取 id 对应线程的执行结果，并根据是否成功处理页面。\n&#x27;&#x27;&#x27;    views.py&#x27;&#x27;&#x27;def get(req):    ...    task = func.delay(params)    id = task.id    data[&#x27;id&#x27;] = id        ...    return render_to_redirect(req, self.TEMPLATE, data=data)\n\n详细的使用 Celery + AJAX 的操作我也不会日后探究 /斜眼笑。\n","categories":["Python","Web","Django","Python"],"tags":["python","django","redis","消息队列"]},{"title":"How to write 'hello world' in HEXO (I)","url":"/2021/04/18/How-to-write-hello-world-in-HEXO-I/","content":"What is HEXO?HEXO is a very famous and useful web framework. People always combine HEXO with GitHub to bulid their own blogs or webpages.\nInstallFirst of all, you need to install node.js, you can refer to its website here, and git, you can refer here.\nAfter configuration, you are supposed to install HEXO via node.js command called npm.\nnpm install -g hexo-cli\n\nInitializeOnce HEXO is installed, run the following commands to initialize HEXO in the target &lt;folder&gt;.\nhexo init &lt;folder&gt;  # initcd &lt;folder&gt;npm install         # install other dependency\n\nOnce initialized, here’s what your project folder will look like:\n.├── _config.yml         # user can config settings here├── package.json        # record dependency etc.├── scaffolds           # define three post methods -- post, draft and page├── source              # store your posts and other resources|   ├── _drafts|   └── _posts└── themes              # user&#39;s custom themes\n\nConfigurationIn _config.yml file, you can stylize your own settings. For example:\n\ntitle – your website’s name\nurl – the URL of your website\n\nyou can find more details here.\nCommandnewhexo new [layout] [-p/--path filePath] &lt;title&gt;\n\nCreates a new article. If no [layout] is provided, Hexo will use the default_layout from _config.yml. \nBy default, Hexo will use the title to define the path of the file. For page, it will create a directory of that name and an index.md file in it. Use the –path option to override that behaviour and define the file path:\nhexo new page --path about/me &quot;About&quot;\nwill create source/about/me.md file with the title “About” set in the front matter.\nFor post, it will automatically generate a new file in source/_posts/&lt;title&gt;.md\nserverhexo serverhexo s\nRun a local server.\ngeneratehexo g\nGenerate static files, which means it will convert/render .md or .ejs files to html files.\ncleanhexo clean\n\nCleans the cache file (db.json) and generated files (public).\ndeployhexo d\n\nDeploy your files to remote server. You can set your deploy destination:\n\nopen _config.yml\nconfigure depoly area, for example, if you want to deploy your website in GitHubdeploy:    type: git    repository: https://github.com/xxx/xxx.github.io.git    branch: master\n\n","categories":["Web","HEXO","Framework","HEXO"],"tags":["hexo","web","framework"]},{"title":"How-to-write-hello-world-in-HEXO-II","url":"/2021/04/19/How-to-write-hello-world-in-HEXO-II/","content":"Post your fileNow, you can begin to write your markdown or ejs files. When you want to post a file, you can just run codes in orders.\n\nhexo new post &lt;fileName&gt;\nwrite something\nhexo clean\nhexo g\nhexo d\n\nFront-matterWhen you new a file, HEXO will automatically generate a file in certain format, it depends on your METHOD (like post, draft and page) in scaffolds.\nFor POST METHOD, it will generate a file with beginning below:\n---title: &lt;fileName&gt;date: &lt;createTime&gt;---\n\nIn HEXO, the beginning area which surrounded by --- is HEXO’s syntax. title represents the file’s title, and data represents the create time. \nFor instance, when we use below Front-matter, we can get corresponding webpage.\n---title: HELLOdate: 2021-04-19---&lt;main&gt;\n\n&lt;h1&gt;HELLO&lt;&#x2F;h1&gt;[Username] &lt;span&gt;2021-04-19&lt;&#x2F;span&gt; &lt;main&gt;\n\n\ncategories &amp; tagsExcept title and date, there are many other key words:\n\ncategories – indicates the categories it belongs to\ntags – indicates the tags it has\n\nNotice: categories is different with tags. tags is unordered, while categories is ordered.\n---title: date:categories:- Web- HEXOtags:- web- hexo---\n\nThis file will be attached tags with “web” and “hexo”, these tags are parallel. However, it also will be archived to Web and HEXO, and Web is father category, HEXO is child category.\n\n\nIf you want to assign many father-child categories, you can use []\ncategories:- [Web, HEXO]- [Web, Framework]\n","categories":["Web","HEXO","Framework","HEXO"],"tags":["hexo","web","framework"]},{"title":"caffe2pytorch","url":"/2021/04/20/caffe2pytorch/","content":"Caffe2PyTorchThis cookbook is a guide about how to transfer Caffe layers to PyTorch functions and networks.\nGuidance\nConv\nBN\nReLU\nReshape\nTranspose\nMatrix Mul\nSoftmax\nCrop\nEltwise\nDeconV\nConcat\n\n\nnn.Conv2dnn.Conv2d(in_channels, out_channels, kernel_size, padding, stride, bias)\nlayer &#123;  name:   type: &quot;Convolution&quot;  bottom:   top:   convolution_param &#123;    num_output: 64    bias_term: true    pad: 3    kernel_size: 7    stride: 2    weight_filler &#123;      type: &quot;msra&quot;    &#125;  &#125;&#125;\n\n\nnn.BatchNorm2dnn.BatchNorm2d(out_channels)\nlayer &#123;  name:   type: &quot;BatchNorm&quot;  bottom:   top:   batch_norm_param &#123;    use_global_stats: false  &#125;&#125;layer &#123;  name:   type: &quot;Scale&quot;  bottom:   top:   scale_param &#123;    bias_term: true  &#125;&#125;\n\n\nnn.ReLUnn.ReLU(inplace=True)\nlayer &#123;  name:   type: &quot;ReLU&quot;  bottom:   top: &#125;\n\n\ntorch.reshapetorch.reshape(x, (n, c, -1)) # caffe中dim=0表示维度不变\nlayer &#123;  name:   type: &quot;Reshape&quot;  bottom:   top:   reshape_param &#123;    shape &#123;      dim: 0      dim: 0      dim: -1    &#125;  &#125;&#125;\n\n\ntorch.transposetorch.transpose(x, dim_0, dim_1)    # torch的transpose只能一次交换两个维度，多个维度需要多次交换\nlayer &#123;  name:   type: &quot;TensorTranspose&quot;  bottom:   top:   tensor_transpose_param &#123;    order: 0    order: 2    order: 1  &#125;&#125;\n\n\ntorch.bmmtorch.bmm(x, y) # bmm针对batch做矩阵乘法，即(n, c, w, h)，如果是(c, w, h)则可以使用bm\nlayer &#123;  name:   type: &quot;MatrixMultiplication&quot;  bottom:   bottom:   top: &#125;\n\n\nF.softmaxF.softmax(x, dim)   # dim即为下面的axis\nlayer &#123;  name:   type: &quot;Softmax&quot;  bottom:   top:   softmax_param &#123;    axis: 2  &#125;&#125;\n\n\nCropclass Crop(nn.Module):    &#x27;&#x27;&#x27;        @ axis      -&gt;      从axis开始裁减后面的维度        @ offset    -&gt;      裁减的时候要偏离多少距离        ! 注意：在Caffe中，是以B的大小来裁减A，即 B.shape &lt;= A.shape    &#x27;&#x27;&#x27;    def __init__(self, axis, offset=0):        super(Crop, self).__init__()        self.axis = axis        self.offset = offset    def forward(self, x, ref):        for axis in range(self.axis, x.dim()):            ref_size = ref.size(axis)            indices = torch.arange(self.offset, self.offset + ref_size).long()            indices = x.data.new().resize_(indices.size()).copy_(indices)            x = x.index_select(axis, indices.to(torch.int64))        return x\nlayer &#123;  name:   type: &quot;Crop&quot;  bottom: A  bottom: B  top:   crop_param &#123;    axis: 2  &#125;&#125;\n\n\nEltwiseclass Eltwise(nn.Module):    def __init__(self, operation=&#x27;+&#x27;):        super(Eltwise, self).__init__()        self.operation = operation    def forward(self, *inputs):        if self.operation == &#x27;+&#x27; or self.operation == &#x27;SUM&#x27;:            x = inputs[0]            for i in range(1,len(inputs)):                x = x + inputs[i]        elif self.operation == &#x27;*&#x27; or self.operation == &#x27;MUL&#x27;:            x = inputs[0]            for i in range(1,len(inputs)):                x = x * inputs[i]        elif self.operation == &#x27;/&#x27; or self.operation == &#x27;DIV&#x27;:            x = inputs[0]            for i in range(1,len(inputs)):                x = x / inputs[i]        elif self.operation == &#x27;MAX&#x27;:            x = inputs[0]            for i in range(1,len(inputs)):                x =torch.max(x, inputs[i])        else:            print(&#x27;forward Eltwise, unknown operator&#x27;)        return x\n\nlayer &#123;  name:   type: &quot;Eltwise&quot;  bottom:   bottom:   top: &#125;layer &#123;  name:   type: &quot;Eltwise&quot;  bottom:   bottom:   top:   eltwise_param &#123;    operation: PROD  &#125;&#125;\n\n\nnn.ConvTranspose2dnn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride, padding, output_padding, groups, bias)\nlayer &#123;  name:   type: &quot;Deconvolution&quot;  bottom:   top:   param &#123;    lr_mult: 0.0  &#125;  convolution_param &#123;    num_output: 128    bias_term: false    pad: 0    kernel_size: 4    group: 128    stride: 2    weight_filler &#123;      type: &quot;bilinear&quot;    &#125;  &#125;&#125;\n\n\nConcatclass Concat(nn.Module):    def __init__(self, axis):        super(Concat, self).__init__()        self.axis = axis    def forward(self, *inputs):        return torch.cat(inputs, self.axis)\n\nlayer &#123;  name:   type: &quot;Concat&quot;  bottom:   bottom:   bottom:   top:   propagate_down: true  propagate_down: true  propagate_down: false  concat_param &#123;    concat_dim: 1  &#125;&#125;\n","categories":["Deep Learning","Framework","PyTorch"],"tags":["Deep Learning","PyTorch"]},{"title":"hexo-pdf","url":"/2021/04/18/hexo-pdf/","content":"If you want to insert .pdf files in your HEXO pages, there are two methods.\n\nMETHOD 0\n\nYou can install HEXO package hexo-pdf.\nnpm install --save hexo-pdf\n\nThen, you can use .ejs syntax &#123;% pdf path %&#125; to achieve function.\n&#123;% pdf https:&#x2F;&#x2F;drive.google.com&#x2F;xxx %&#125;  # external url&#123;% pdf .&#x2F;xxx.pdf %&#125;                     # file path\n\n\nMETHOD 1\n\nIn your index.md, you can use html syntax to achieve this function.\n&lt;object data=&quot;https://drive.google.com/xxx&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;&lt;object data=&quot;./xxx.pdf&quot; type=&quot;application/pdf&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;\n\n\nYou can adjust the width and height even other properties.\n\n","categories":["Web","HEXO","Framework","HEXO"],"tags":["hexo","web","package"]},{"title":"编译型语言和解释型语言","url":"/2021/04/19/%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E5%92%8C%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80/","content":"编译型语言和解释型语言计算机是不能理解高级语言的，更不能直接执行高级语言，它只能直接理解机器语言，所以使用任何高级语言编写的程序若想被计算机运行，都必须将其转换成计算机语言，也就是机器码。而转换主要有两种方法\n\n编译 – 先进行转换，然后再运行\n\n解释 – 运行的过程中进行转换\n\n\n编译型语言使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式(如.exe)。由于已经生成了可执行格式，以后运行时不需要编译，所以编译型语言执行效率高(编译一次，多次使用)。\n一般而言，编译型语言有以下特点：\n\n编译后无需再次编译，性能好\n针对特定平台，跨平台性能差\n\n由于有以上的特点，所以编译型语言常用于OS，嵌入式等对性能要求极高的特定平台，所以衍生出的经典语言类型有 – C/C++\n解释型语言使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。\n一般而言，解释型语言有以下特点：\n\n由于在执行时再翻译，每次执行都要翻译，效率低\n只要对应平台有相应的解释器即可运行，跨平台性能好，便于移植\n\n由于有以上的特点，所以解释型语言常用于Web，脚本等跨平台使用的场景，所以衍生出的经典语言类型有 – Python, Javascript\n关于JavaJava是一种很特殊的语言，其需要将.java文件通过编译生成.class文件，但是该.class文件却可以在各种平台上使用，因为java针对不同的平台有不同的JVM，实现了跨平台。\n\n\n你可以说它是编译型的：因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。 \n你可以说它是解释型的：因为java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的，那也就算是解释的了。 \n但是，现在的JVM为了效率，都有一些JIT优化。它又会把.class的二进制代码编译为本地的代码直接运行，所以，又是编译的。\n\n\n\n为什么需要编译编译有两个主要的好处：\n\n可以提前排除错误;\n对于Java而言，编译并不会直接像C++一样产生基于特定系统的机器码，而是会产生一个二进制比特文件(又称为class文件)，这个文件可以在多种平台被识别(通过JVM)，然后再基于特定的系统进一步进行翻译，实现跨平台与高效率的trade-off\n\n","categories":["Program Language","Java"],"tags":["Java","Concept"]}]